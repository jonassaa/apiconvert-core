{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Apiconvert.Core Documentation","text":"<p>Apiconvert.Core is a rule-driven payload conversion engine with matching behavior across the .NET package (<code>Apiconvert.Core</code>) and TypeScript package (<code>@apiconvert/core</code>).</p> <p>Use the runtime selector in the header to switch runtime-specific snippets.</p>"},{"location":"#what-this-site-covers","title":"What this site covers","text":"<ul> <li>core conversion model and architectural boundaries</li> <li>end-to-end usage for both runtimes</li> <li>canonical rules reference and schema contract</li> <li>diagnostics, troubleshooting, and parity verification</li> <li>CI/release/versioning guidance for docs and package consumers</li> </ul>"},{"location":"#fast-paths","title":"Fast paths","text":"<ul> <li>New adopters: go to <code>Start Here</code>.</li> <li>Existing users: jump to <code>Rules Reference</code>, <code>Runtime Guides</code>, or <code>CLI and Tooling</code>.</li> </ul>"},{"location":"cli-tooling/cli-reference/","title":"CLI Reference","text":"<p>Examples:</p> <pre><code>apiconvert rules validate rules.json\napiconvert rules lint rules.json\napiconvert rules doctor --rules rules.json --input sample.json --format json\napiconvert convert --rules rules.json --input input.json --output out.json\n</code></pre>"},{"location":"cli-tooling/compatibility-checks/","title":"Compatibility Checks","text":"<p>Run compatibility checks against target versions before rolling out rule updates.</p>"},{"location":"cli-tooling/plan-profiling/","title":"Plan Profiling","text":"<p>Use profile tools to measure conversion plan compile/apply latency percentiles with representative samples.</p>"},{"location":"cli-tooling/rules-bundling/","title":"Rules Bundling","text":"<p>Use bundling to resolve modular rules with includes into a deterministic single artifact for deployment.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>This section covers local setup, documentation conventions, release flow, and governance expectations for rule/schema changes.</p>"},{"location":"contributing/#github-pages-docs","title":"GitHub Pages docs","text":"<ul> <li>Build locally with <code>mkdocs build --strict</code>.</li> <li>Serve docs with <code>mkdocs serve</code>.</li> <li>Follow the runtime-tagging rules in the docs authoring guide.</li> </ul> <p>Continue with:</p> <ul> <li><code>Local Setup</code></li> <li><code>Docs Authoring Guide</code></li> <li><code>Release Flow</code></li> <li><code>Governance</code></li> </ul>"},{"location":"contributing/docs-authoring-guide/","title":"Docs Authoring Guide","text":""},{"location":"contributing/docs-authoring-guide/#runtime-tagged-content","title":"Runtime-tagged content","text":"<p>Use runtime classes only for runtime-specific text/code:</p> <ul> <li><code>&lt;div class=\"runtime-dotnet\"&gt;...&lt;/div&gt;</code></li> <li><code>&lt;div class=\"runtime-typescript\"&gt;...&lt;/div&gt;</code></li> </ul> <p>Keep shared conceptual text untagged.</p>"},{"location":"contributing/docs-authoring-guide/#parity-authoring-rules","title":"Parity authoring rules","text":"<ul> <li>if behavior differs, explain why</li> <li>keep equivalent examples for both runtimes</li> <li>update shared case references when examples change behavior</li> </ul>"},{"location":"contributing/docs-authoring-guide/#versioning","title":"Versioning","text":"<ul> <li>deploy versioned docs via <code>mike</code></li> <li>keep <code>latest</code> aligned with active release branch/tag stream</li> </ul>"},{"location":"contributing/governance/","title":"Governance","text":"<p>Rule/schema changes must be reviewed for:</p> <ul> <li>compatibility impact</li> <li>deterministic behavior</li> <li>cross-runtime parity</li> <li>shared case coverage</li> </ul>"},{"location":"contributing/local-setup/","title":"Local Setup","text":"<pre><code>dotnet build Apiconvert.Core.sln\ndotnet test Apiconvert.Core.sln\nnpm --prefix tests/npm/apiconvert-core-tests test\n</code></pre> <p>For docs:</p> <pre><code>python3 -m venv .venv-docs\nsource .venv-docs/bin/activate\npip install -r requirements-docs.txt\nmkdocs serve\n</code></pre>"},{"location":"contributing/release-flow/","title":"Release Flow","text":"<p>Publishing is tag-driven:</p> <ol> <li>create release tag workflow (<code>patch</code>, <code>minor</code>, <code>major</code>)</li> <li>workflow creates <code>vX.Y.Z</code></li> <li>package publish pipeline releases NuGet and npm artifacts</li> <li>docs pipeline publishes matching version docs</li> </ol>"},{"location":"core-concepts/conversion-lifecycle/","title":"Conversion Lifecycle","text":""},{"location":"core-concepts/conversion-lifecycle/#lifecycle","title":"Lifecycle","text":"<ol> <li>Parse payload by <code>inputFormat</code>.</li> <li>Normalize rules (strict or lenient).</li> <li>Apply conversion.</li> <li>Inspect errors/warnings/trace.</li> <li>Format payload by <code>outputFormat</code>.</li> </ol>"},{"location":"core-concepts/conversion-lifecycle/#recommended-production-flow","title":"Recommended production flow","text":"<ul> <li>normalize strict at startup or build time</li> <li>compile conversion plan for repeated runs</li> <li>apply with explicit collision policy</li> <li>include trace mode when debugging</li> </ul>"},{"location":"core-concepts/determinism/","title":"Determinism","text":"<p>Deterministic behavior means the same input payload + same normalized rules must produce the same output and diagnostics.</p>"},{"location":"core-concepts/determinism/#in-practice","title":"In practice","text":"<ul> <li>rules are normalized before use</li> <li>conversion does not mutate input payloads</li> <li>collision handling is policy-based and explicit</li> <li>tracing is ordered by rule execution path</li> </ul>"},{"location":"core-concepts/intent-and-boundaries/","title":"Intent and Boundaries","text":"<p>Apiconvert.Core is conversion logic only.</p>"},{"location":"core-concepts/intent-and-boundaries/#intent","title":"Intent","text":"<ul> <li>rule-driven API transformation</li> <li>deterministic and side-effect-free execution</li> <li>parity between .NET and TypeScript runtimes</li> </ul>"},{"location":"core-concepts/intent-and-boundaries/#out-of-scope","title":"Out of scope","text":"<ul> <li>API gateway and proxy features</li> <li>auth, HTTP, persistence, orchestration, and UI concerns</li> <li>external I/O in conversion paths</li> </ul>"},{"location":"core-concepts/rules-model/","title":"Canonical Rules Model","text":"<p>Rules are an ordered recursive tree under one <code>rules</code> array.</p>"},{"location":"core-concepts/rules-model/#node-kinds","title":"Node kinds","text":"<ul> <li><code>field</code></li> <li><code>array</code></li> <li><code>branch</code></li> <li><code>use</code> (fragment expansion)</li> </ul>"},{"location":"core-concepts/rules-model/#supported-formats","title":"Supported formats","text":"<ul> <li><code>json</code></li> <li><code>xml</code></li> <li><code>query</code></li> </ul>"},{"location":"core-concepts/rules-model/#supported-source-types","title":"Supported source types","text":"<ul> <li><code>path</code></li> <li><code>constant</code></li> <li><code>transform</code></li> <li><code>merge</code></li> <li><code>condition</code></li> </ul>"},{"location":"diagnostics/error-codes/","title":"Error Codes","text":"<p>Diagnostics use stable, deterministic codes.</p> <ul> <li>conversion diagnostics: runtime mapping/execution issues</li> <li>rules diagnostics: schema and semantic validation issues</li> </ul> <p>Use the catalog to map code to remediation steps.</p>"},{"location":"diagnostics/lint-diagnostics/","title":"Lint Diagnostics","text":"<p>Lint diagnostics are non-mutating findings intended for author feedback.</p> <p>Each includes:</p> <ul> <li>severity</li> <li>code</li> <li>rule path</li> <li>message</li> <li>optional fix hints</li> </ul>"},{"location":"diagnostics/rule-doctor-workflow/","title":"Rule Doctor Workflow","text":"<p>Rule doctor combines validation and linting (and optional runtime diagnostics) into one report.</p> <p>Use it to gate rule changes before release.</p>"},{"location":"diagnostics/troubleshooting-tree/","title":"Troubleshooting Decision Tree","text":"<ol> <li>parse failure -&gt; validate input format and parser assumptions</li> <li>strict normalization failure -&gt; fix schema/rule shape</li> <li>runtime conversion errors -&gt; inspect rule path and source resolution</li> <li>unexpected output -&gt; enable trace and compare execution paths</li> <li>parity mismatch -&gt; run shared case in both runtimes and parity gate</li> </ol>"},{"location":"parity-testing/add-new-case/","title":"Add a New Shared Case","text":"<ol> <li>create <code>tests/cases/&lt;case-name&gt;/</code></li> <li>add input/rules/output artifacts</li> <li>run .NET tests</li> <li>run npm tests</li> <li>run parity gate and verify pass</li> </ol>"},{"location":"parity-testing/parity-gate-ci/","title":"Parity Gate CI","text":"<p>Use parity gate reports to enforce behavior alignment:</p> <ul> <li><code>tests/parity/parity-report.json</code></li> <li><code>tests/parity/parity-summary.json</code></li> </ul> <p>Integrate checks into pull request workflows.</p>"},{"location":"parity-testing/runtime-parity-workflow/","title":"Runtime Parity Workflow","text":"<p>Run both suites when changing conversion behavior:</p> <pre><code>dotnet test Apiconvert.Core.sln\nnpm --prefix tests/npm/apiconvert-core-tests test\n</code></pre> <p>Then run parity gate tooling.</p>"},{"location":"parity-testing/shared-cases/","title":"Shared Cases","text":"<p><code>tests/cases</code> is the canonical shared behavior suite across .NET and npm.</p> <p>Each case should include:</p> <ul> <li><code>input.*</code></li> <li><code>rules.json</code></li> <li><code>output.*</code></li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/","title":"GitHub Pages Documentation Site Design","text":"<p>Date: 2026-02-22 Project: Apiconvert.Core Status: Approved</p>"},{"location":"plans/2026-02-22-github-pages-docs-design/#goal","title":"Goal","text":"<p>Build a comprehensive GitHub Pages documentation site for Apiconvert.Core using MkDocs + Material, with a top-level runtime selector that switches between .NET and TypeScript content while keeping one unified documentation flow.</p>"},{"location":"plans/2026-02-22-github-pages-docs-design/#audience","title":"Audience","text":"<ul> <li>New adopters evaluating Apiconvert.Core</li> <li>Existing users needing deep reference documentation</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#chosen-approach","title":"Chosen Approach","text":"<p>Approach 1: Single docs source + runtime toggle + versioned deploy (<code>mike</code>).</p>"},{"location":"plans/2026-02-22-github-pages-docs-design/#why-this-approach","title":"Why this approach","text":"<ul> <li>Maintains one canonical conceptual narrative across runtimes</li> <li>Preserves cross-runtime parity intent</li> <li>Minimizes duplication and long-term drift</li> <li>Supports a strong onboarding experience and fast reference lookup</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#information-architecture","title":"Information Architecture","text":"<p>Top-level navigation: - Start Here - Core Concepts - Runtime Guides - Rules Reference - Recipes - Diagnostics &amp; Troubleshooting - Schema &amp; Versioning - Parity &amp; Testing - CLI &amp; Tooling - Contributing</p>"},{"location":"plans/2026-02-22-github-pages-docs-design/#detailed-page-map","title":"Detailed Page Map","text":""},{"location":"plans/2026-02-22-github-pages-docs-design/#start-here","title":"Start Here","text":"<ul> <li>Overview</li> <li>Install (.NET / npm)</li> <li>First Conversion (runtime-switched walkthrough)</li> <li>Migration from hand-written mappers</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#core-concepts","title":"Core Concepts","text":"<ul> <li>Architectural Intent &amp; Boundaries</li> <li>Determinism and Side Effects</li> <li>Canonical Rules Model</li> <li>Conversion Lifecycle (parse -&gt; normalize -&gt; apply -&gt; format)</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#runtime-guides","title":"Runtime Guides","text":"<ul> <li>Runtime Selector UX</li> <li>.NET API Usage Guide</li> <li>TypeScript API Usage Guide</li> <li>Streaming in .NET and Node</li> <li>Custom Transform Plugins</li> <li>Performance and plan caching</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#rules-reference","title":"Rules Reference","text":"<ul> <li>Rule node types (field/array/branch/use)</li> <li>Sources and transforms</li> <li>Condition expression grammar</li> <li>Merge modes and collision policy</li> <li>Fragments and includes</li> <li>Schema validation behavior (strict/lenient)</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#recipes","title":"Recipes","text":"<ul> <li>JSON &lt;&gt; XML patterns</li> <li>JSON &lt;&gt; query patterns</li> <li>Array/branch/merge/split cookbook</li> <li>Diagnostics-first authoring flow</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#diagnostics-troubleshooting","title":"Diagnostics &amp; Troubleshooting","text":"<ul> <li>Error code catalog</li> <li>Lint diagnostics reference</li> <li>Rule doctor workflow</li> <li>Troubleshooting decision tree</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#schema-versioning","title":"Schema &amp; Versioning","text":"<ul> <li>Schema compatibility contract</li> <li>SemVer lockstep policy</li> <li>Version pinning (<code>current</code> vs <code>vX.Y.Z</code>)</li> <li>Breaking change policy</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#parity-testing","title":"Parity &amp; Testing","text":"<ul> <li>Shared test cases model</li> <li>.NET + npm parity workflow</li> <li>Parity gate CI integration</li> <li>How to add a new shared case</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#cli-tooling","title":"CLI &amp; Tooling","text":"<ul> <li>CLI command reference</li> <li>Rules bundling</li> <li>Plan profiling</li> <li>Compatibility checks</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#contributing","title":"Contributing","text":"<ul> <li>Local dev setup</li> <li>Docs contribution guide</li> <li>Release flow (tag-driven)</li> <li>Governance for rule/schema changes</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#technical-design","title":"Technical Design","text":"<ul> <li>Tooling: MkDocs + Material</li> <li>Deployment target: GitHub Pages via <code>gh-pages</code> branch, deployed by GitHub Actions</li> <li>Versioning: enabled from day one via <code>mike</code></li> <li>Content source: replace existing <code>/docs</code> with the new site content and structure</li> <li>Runtime switching: top app-level selector in header (<code>.NET</code>, <code>TypeScript</code>)</li> <li>Runtime visibility: non-selected runtime content is fully hidden</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#runtime-selector-behavior","title":"Runtime selector behavior","text":"<ul> <li>Selector state persisted in <code>localStorage</code></li> <li>Selector applied globally across pages</li> <li>Runtime-specific content blocks tagged by runtime class</li> <li>Untagged content remains always visible</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#validation-strategy","title":"Validation Strategy","text":"<ul> <li><code>mkdocs build --strict</code> required in CI</li> <li>Link and nav integrity validated on docs pull requests</li> <li>Runtime selector behavior validated with Playwright checks:</li> <li>default runtime rendering</li> <li>selector toggle persistence</li> <li>non-selected runtime content hidden</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#maintainability-strategy","title":"Maintainability Strategy","text":"<ul> <li>Unified pages with runtime-tagged snippets only where needed</li> <li>Docs authoring guide defines tagging, parity expectations, and version update workflow</li> <li>Canonical reference pages for rules/schema/diagnostics to prevent drift</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#migration-policy","title":"Migration Policy","text":"<ul> <li>Replace existing <code>/docs</code> content with the new docs site structure</li> <li>Preserve key legacy knowledge by integrating into the new IA rather than keeping disconnected legacy pages</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#non-goals","title":"Non-Goals","text":"<ul> <li>Building UI rule editors</li> <li>Adding runtime behavior not present in package APIs</li> <li>Introducing non-deterministic or integration-layer guidance into core docs</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-design/#open-follow-ups","title":"Open Follow-ups","text":"<ul> <li>Confirm first published docs version label strategy (<code>latest</code> + semantic versions)</li> <li>Decide how to map release tags to version publish automation cadence</li> </ul>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/","title":"GitHub Pages Documentation Site Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace <code>/docs</code> with a comprehensive MkDocs + Material documentation site for Apiconvert.Core, including a global runtime selector (.NET/TypeScript), strict build validation, and versioned GitHub Pages deployment via <code>gh-pages</code>.</p> <p>Architecture: Use a single unified docs source in <code>/docs</code> and runtime-specific content blocks controlled by a global selector injected through MkDocs theme overrides. Build locally with strict checks, then publish versioned docs using <code>mike</code> in GitHub Actions. Keep the canonical conceptual model shared while hiding runtime-specific snippets based on selector state.</p> <p>Tech Stack: MkDocs, Material for MkDocs, mike (versioned docs), GitHub Actions, JavaScript/CSS theme overrides, markdown content in <code>/docs</code>.</p>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-1-bootstrap-mkdocs-docs-toolchain","title":"Task 1: Bootstrap MkDocs Docs Toolchain","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/mkdocs.yml</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/requirements-docs.txt</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/.gitignore</code></p> <p>Step 1: Write the failing build check</p> <p>Add a temporary CI/local expectation in plan notes: <code>mkdocs build --strict</code> should fail before config exists.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; mkdocs build --strict</code> Expected: FAIL with missing <code>mkdocs.yml</code>.</p> <p>Step 3: Write minimal implementation</p> <p>Create <code>mkdocs.yml</code> with: - site metadata - Material theme - plugins (<code>search</code>) - markdown extensions needed for tabs/admonitions/code highlighting - nav placeholders for full IA</p> <p>Create <code>requirements-docs.txt</code> with pinned docs dependencies.</p> <p>Update <code>.gitignore</code> for local docs build output (<code>site/</code>).</p> <p>Step 4: Run check to verify it passes</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; python3 -m venv .venv-docs</code> - <code>source .venv-docs/bin/activate &amp;&amp; pip install -r requirements-docs.txt</code> - <code>mkdocs build --strict</code> Expected: PASS or only missing-page errors to be fixed in next task.</p> <p>Step 5: Commit</p> <pre><code>git add mkdocs.yml requirements-docs.txt .gitignore\ngit commit -m \"docs: bootstrap mkdocs toolchain\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-2-replace-existing-docs-content-with-new-ia-skeleton","title":"Task 2: Replace Existing <code>/docs</code> Content With New IA Skeleton","text":"<p>Files: - Modify/Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/*.md</code> (replace current structure) - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/start-here/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/core-concepts/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/runtime-guides/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/rules-reference/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/recipes/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/diagnostics/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/schema-versioning/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/parity-testing/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/cli-tooling/*.md</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/contributing/*.md</code></p> <p>Step 1: Write the failing nav/content check</p> <p>Define all target nav pages in <code>mkdocs.yml</code> before creating files.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; source .venv-docs/bin/activate &amp;&amp; mkdocs build --strict</code> Expected: FAIL with missing docs files referenced by nav.</p> <p>Step 3: Write minimal implementation</p> <p>Create all required pages with initial complete section outlines and key content migrated/expanded from: - legacy <code>/docs</code> - repository <code>README.md</code> - runtime READMEs under <code>src/Apiconvert.Core/README.md</code> and <code>src/apiconvert-core/README.md</code></p> <p>Step 4: Run check to verify it passes</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; source .venv-docs/bin/activate &amp;&amp; mkdocs build --strict</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add docs mkdocs.yml\ngit commit -m \"docs: replace docs with comprehensive ia structure\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-3-add-runtime-selector-global-header-level-hidden-non-selected-content","title":"Task 3: Add Runtime Selector (Global, Header-Level, Hidden Non-Selected Content)","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/overrides/main.html</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/assets/javascripts/runtime-selector.js</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/assets/stylesheets/runtime-selector.css</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/mkdocs.yml</code></p> <p>Step 1: Write the failing selector behavior check</p> <p>Add a small local assertion script (or manual checklist) expecting runtime selector element and runtime classes in built HTML.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; source .venv-docs/bin/activate &amp;&amp; mkdocs build --strict &amp;&amp; rg -n \"runtime-selector|runtime-dotnet|runtime-typescript\" site -S</code> Expected: FAIL or empty results before implementation.</p> <p>Step 3: Write minimal implementation</p> <p>Implement selector UI in <code>overrides/main.html</code>, JS state persistence in <code>localStorage</code>, body class toggling, and CSS that hides non-selected runtime blocks.</p> <p>Update <code>mkdocs.yml</code> with <code>theme.custom_dir</code>, extra JS, and extra CSS.</p> <p>Step 4: Run check to verify it passes</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; source .venv-docs/bin/activate &amp;&amp; mkdocs build --strict &amp;&amp; rg -n \"runtime-selector|runtime-dotnet|runtime-typescript\" site -S</code> Expected: PASS with matches present.</p> <p>Step 5: Commit</p> <pre><code>git add docs/overrides docs/assets mkdocs.yml\ngit commit -m \"docs: add global runtime selector with hidden non-selected blocks\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-4-apply-runtime-tagged-content-across-key-pages","title":"Task 4: Apply Runtime-Tagged Content Across Key Pages","text":"<p>Files: - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/start-here/first-conversion.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/runtime-guides/dotnet-api-usage.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/runtime-guides/typescript-api-usage.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/runtime-guides/streaming.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/recipes/*.md</code></p> <p>Step 1: Write the failing parity-content check</p> <p>Define a lint rule/grep check that key pages include both runtime-tagged snippets where applicable.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"runtime-dotnet|runtime-typescript\" docs/start-here docs/runtime-guides docs/recipes -S</code> Expected: FAIL for incomplete runtime tags.</p> <p>Step 3: Write minimal implementation</p> <p>Annotate runtime-specific code and guidance with consistent runtime block classes while keeping shared prose untagged.</p> <p>Step 4: Run check to verify it passes</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; source .venv-docs/bin/activate &amp;&amp; mkdocs build --strict</code> - <code>rg -n \"runtime-dotnet|runtime-typescript\" docs/start-here docs/runtime-guides docs/recipes -S</code> Expected: PASS with adequate tagged coverage.</p> <p>Step 5: Commit</p> <pre><code>git add docs/start-here docs/runtime-guides docs/recipes\ngit commit -m \"docs: add runtime-tagged content for dotnet and typescript\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-5-add-authoring-rules-and-contributor-guidance","title":"Task 5: Add Authoring Rules and Contributor Guidance","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/docs/contributing/docs-authoring-guide.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/docs/contributing/index.md</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/README.md</code></p> <p>Step 1: Write the failing docs-contrib discoverability check</p> <p>Add expected links to authoring guide in nav and repository README.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"docs-authoring-guide|GitHub Pages docs\" README.md docs -S</code> Expected: FAIL before links exist.</p> <p>Step 3: Write minimal implementation</p> <p>Document: - runtime tagging rules - parity update checklist - style and page ownership expectations - version update procedure with <code>mike</code></p> <p>Link this from docs nav and top-level README.</p> <p>Step 4: Run check to verify it passes</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"docs-authoring-guide|GitHub Pages docs\" README.md docs -S</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add docs/contributing README.md\ngit commit -m \"docs: add docs authoring and maintenance guide\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-6-add-github-actions-workflow-for-versioned-github-pages-deploy","title":"Task 6: Add GitHub Actions Workflow for Versioned GitHub Pages Deploy","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/.github/workflows/docs-pages.yml</code></p> <p>Step 1: Write the failing workflow validation check</p> <p>Run action lint or YAML validation expecting missing docs workflow.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"docs-pages|mike\" .github/workflows -S</code> Expected: FAIL before workflow exists.</p> <p>Step 3: Write minimal implementation</p> <p>Create workflow with: - trigger on docs/mkdocs changes + manual dispatch - Python setup + dependency install - <code>mkdocs build --strict</code> - <code>mike deploy</code> and <code>mike set-default</code> to <code>gh-pages</code> - proper Pages permissions and concurrency</p> <p>Step 4: Run check to verify it passes</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"mike deploy|gh-pages|mkdocs build --strict\" .github/workflows/docs-pages.yml -S</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add .github/workflows/docs-pages.yml\ngit commit -m \"ci: add versioned github pages docs deploy workflow\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-7-add-local-docs-helper-commands","title":"Task 7: Add Local Docs Helper Commands","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/scripts/docs-serve.sh</code> - Create: <code>/Users/jonas/dev/fun/apiconvert-core/scripts/docs-build.sh</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/README.md</code></p> <p>Step 1: Write the failing helper-command check</p> <p>Attempt to run helper scripts before they exist.</p> <p>Step 2: Run check to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; ls scripts/docs-serve.sh scripts/docs-build.sh</code> Expected: FAIL (missing files).</p> <p>Step 3: Write minimal implementation</p> <p>Add executable scripts to: - bootstrap venv if missing - install docs deps - run <code>mkdocs serve</code> / <code>mkdocs build --strict</code></p> <p>Document usage in README.</p> <p>Step 4: Run check to verify it passes</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; bash scripts/docs-build.sh</code> - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; timeout 8 bash scripts/docs-serve.sh || true</code> Expected: build PASS; serve starts without config/runtime errors.</p> <p>Step 5: Commit</p> <pre><code>git add scripts/docs-serve.sh scripts/docs-build.sh README.md\ngit commit -m \"docs: add local docs build and serve helper scripts\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-8-add-runtime-selector-verification-test","title":"Task 8: Add Runtime Selector Verification Test","text":"<p>Files: - Create: <code>/Users/jonas/dev/fun/apiconvert-core/tests/docs/runtime-selector.smoke.mjs</code> - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/package.json</code> (or docs-specific script location) - Modify: <code>/Users/jonas/dev/fun/apiconvert-core/.github/workflows/docs-pages.yml</code></p> <p>Step 1: Write the failing test</p> <p>Add a smoke script that opens built docs and checks: - selector exists - selecting <code>.NET</code> hides TS blocks - selecting <code>TypeScript</code> hides .NET blocks</p> <p>Step 2: Run test to verify it fails</p> <p>Run: <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; node tests/docs/runtime-selector.smoke.mjs</code> Expected: FAIL before script/fixture setup is complete.</p> <p>Step 3: Write minimal implementation</p> <p>Implement smoke test with Playwright against local built <code>site/</code> served with a simple static server.</p> <p>Step 4: Run test to verify it passes</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; bash scripts/docs-build.sh</code> - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; node tests/docs/runtime-selector.smoke.mjs</code> Expected: PASS.</p> <p>Step 5: Commit</p> <pre><code>git add tests/docs .github/workflows/docs-pages.yml package.json\ngit commit -m \"test: add runtime selector smoke verification for docs\"\n</code></pre>"},{"location":"plans/2026-02-22-github-pages-docs-implementation/#task-9-final-verification-and-cleanup","title":"Task 9: Final Verification and Cleanup","text":"<p>Files: - Modify as needed based on failures</p> <p>Step 1: Run full verification suite</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; bash scripts/docs-build.sh</code> - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; mkdocs build --strict</code> - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; node tests/docs/runtime-selector.smoke.mjs</code></p> <p>Expected: all PASS.</p> <p>Step 2: Validate workflow and docs discoverability</p> <p>Run: - <code>cd /Users/jonas/dev/fun/apiconvert-core &amp;&amp; rg -n \"docs-pages|GitHub Pages|runtime selector|mike\" README.md docs .github/workflows -S</code> Expected: PASS with expected references.</p> <p>Step 3: Commit final fixes</p> <pre><code>git add -A\ngit commit -m \"docs: finalize comprehensive github pages documentation site\"\n</code></pre>"},{"location":"recipes/arrays-branches-merge-split/","title":"Arrays Branches Merge Split","text":"<p>Patterns:</p> <ul> <li>array mapping with <code>coerceSingle</code></li> <li>branch-based defaults and fallbacks</li> <li>merge with <code>firstNonEmpty</code></li> <li>split token extraction with optional trim</li> </ul>   ## .NET policy hint  Set collision behavior with `new ConversionOptions { CollisionPolicy = OutputCollisionPolicy.Error }` during recipe validation.     ## TypeScript policy hint  Set collision behavior with `{ collisionPolicy: OutputCollisionPolicy.Error }` during recipe validation."},{"location":"recipes/diagnostics-first-authoring/","title":"Diagnostics-first Authoring","text":"<p>Suggested loop:</p> <ol> <li>write minimal rule set</li> <li>run strict normalize</li> <li>run lint and rule doctor</li> <li>add shared case</li> <li>promote to production rule bundle</li> </ol>   ## .NET commands  <pre><code>dotnet test Apiconvert.Core.sln --filter RuleDoctorTests\n</code></pre>   ## TypeScript commands  <pre><code>npm --prefix tests/npm/apiconvert-core-tests test -- --grep \\\"rule doctor\\\"\n</code></pre>"},{"location":"recipes/json-and-query/","title":"JSON and Query Recipes","text":"<ul> <li>convert JSON objects to querystring records</li> <li>parse query values into typed JSON using transforms</li> <li>handle list-like query values with split/array patterns</li> </ul>   ## .NET helpers  - `ConversionEngine.ParsePayload(..., DataFormat.Query)` - `ConversionEngine.FormatPayload(..., DataFormat.Query, pretty: false)`     ## TypeScript helpers  - `parsePayload(..., DataFormat.Query)` - `formatPayload(..., DataFormat.Query, false)`"},{"location":"recipes/json-and-xml/","title":"JSON and XML Recipes","text":"<ul> <li>map JSON fields into XML elements/attributes</li> <li>map XML attributes into JSON fields</li> <li>use arrays and branches for mixed nested structures</li> </ul> <p>Use shared cases under <code>tests/cases</code> for parity verification.</p>   ## .NET runner sketch  <pre><code>var rules = ConversionEngine.NormalizeConversionRulesStrict(File.ReadAllText(\"rules.json\"));\nvar (input, err) = ConversionEngine.ParsePayload(File.ReadAllText(\"input.json\"), rules.InputFormat);\nvar result = ConversionEngine.ApplyConversion(input!, rules);\nvar output = ConversionEngine.FormatPayload(result.Output, rules.OutputFormat, pretty: true);\n</code></pre>   ## TypeScript runner sketch  <pre><code>const rules = normalizeConversionRulesStrict(readFileSync(\"rules.json\", \"utf8\"));\nconst { value } = parsePayload(readFileSync(\"input.json\", \"utf8\"), rules.inputFormat!);\nconst result = applyConversion(value, rules);\nconst output = formatPayload(result.output, rules.outputFormat!, true);\n</code></pre>"},{"location":"rules-reference/condition-expressions/","title":"Condition Expressions","text":"<p>Expressions support:</p> <ul> <li><code>path(...)</code></li> <li><code>exists(...)</code></li> <li>comparisons: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li> <li>boolean operators: <code>&amp;&amp;</code>, <code>||</code>, <code>!</code></li> </ul> <p>Examples:</p> <ul> <li><code>path(score) &gt;= 70</code></li> <li><code>path($.meta.source) == 'api' &amp;&amp; exists(path(value))</code></li> </ul>"},{"location":"rules-reference/fragments-and-includes/","title":"Fragments and Includes","text":""},{"location":"rules-reference/fragments-and-includes/#fragments","title":"Fragments","text":"<p>Use a <code>fragments</code> map for reusable nodes and reference by <code>{ \"use\": \"name\" }</code>.</p>"},{"location":"rules-reference/fragments-and-includes/#includes","title":"Includes","text":"<p>Use rules bundling to resolve modular include files into one deterministic rules object before deployment.</p>"},{"location":"rules-reference/merge-and-collision/","title":"Merge and Collision Policy","text":""},{"location":"rules-reference/merge-and-collision/#merge-modes","title":"Merge modes","text":"<ul> <li><code>concat</code></li> <li><code>firstNonEmpty</code></li> <li><code>array</code></li> </ul>"},{"location":"rules-reference/merge-and-collision/#collision-policies","title":"Collision policies","text":"- `LastWriteWins` - `FirstWriteWins` - `Error`     - `lastWriteWins` - `firstWriteWins` - `error`"},{"location":"rules-reference/node-types/","title":"Rule Node Types","text":""},{"location":"rules-reference/node-types/#field","title":"<code>field</code>","text":"<p>Maps a source value to one or more output paths.</p>"},{"location":"rules-reference/node-types/#array","title":"<code>array</code>","text":"<p>Iterates array input path and executes recursive <code>itemRules</code>.</p>"},{"location":"rules-reference/node-types/#branch","title":"<code>branch</code>","text":"<p>Evaluates an expression and executes <code>then</code>, optional <code>elseIf</code>, optional <code>else</code>.</p>"},{"location":"rules-reference/node-types/#use","title":"<code>use</code>","text":"<p>Expands a named fragment, optionally with overrides.</p>"},{"location":"rules-reference/sources-and-transforms/","title":"Sources and Transforms","text":""},{"location":"rules-reference/sources-and-transforms/#sources","title":"Sources","text":"<ul> <li><code>path</code></li> <li><code>constant</code></li> <li><code>transform</code></li> <li><code>merge</code></li> <li><code>condition</code></li> </ul>"},{"location":"rules-reference/sources-and-transforms/#built-in-transforms","title":"Built-in transforms","text":"<ul> <li><code>toLowerCase</code></li> <li><code>toUpperCase</code></li> <li><code>number</code></li> <li><code>boolean</code></li> <li><code>concat</code></li> <li><code>split</code></li> </ul> <p>Use <code>customTransform</code> for runtime-registered deterministic logic.</p>"},{"location":"rules-reference/validation-modes/","title":"Validation Modes","text":""},{"location":"rules-reference/validation-modes/#strict","title":"Strict","text":"<p>Throws on invalid rules. Use for production startup and CI enforcement.</p>"},{"location":"rules-reference/validation-modes/#lenient","title":"Lenient","text":"<p>Returns normalized rules with validation errors attached. Use in tooling/editor workflows.</p>"},{"location":"rules-reference/validation-modes/#diagnostics","title":"Diagnostics","text":"<p>Run lint and rule doctor to combine validation and quality signals.</p>"},{"location":"runtime-guides/custom-transforms/","title":"Custom Transforms","text":"<p>Use runtime-registered deterministic functions and reference them via <code>source.customTransform</code>.</p>"},{"location":"runtime-guides/custom-transforms/#guidelines","title":"Guidelines","text":"<ul> <li>keep transform functions pure</li> <li>do not perform I/O</li> <li>keep output deterministic for same input</li> </ul>"},{"location":"runtime-guides/dotnet-api-usage/","title":".NET API Usage","text":"Use `ConversionEngine` for normalize/parse/apply/format workflows.  <pre><code>var rules = ConversionEngine.NormalizeConversionRulesStrict(rulesText);\nvar plan = ConversionEngine.CompileConversionPlan(rules);\nvar result = plan.Apply(input);\n</code></pre>  Key APIs:  - `NormalizeConversionRulesStrict` - `ApplyConversion` - `CompileConversionPlan` - `RunRuleDoctor` - `LintRules`"},{"location":"runtime-guides/performance-and-caching/","title":"Performance and Caching","text":""},{"location":"runtime-guides/performance-and-caching/#recommendations","title":"Recommendations","text":"<ul> <li>compile conversion plans for repeated rule sets</li> <li>use cache keys for memoized plan lookup</li> <li>benchmark on representative input sets</li> <li>profile compile/apply separately</li> </ul>"},{"location":"runtime-guides/runtime-selector/","title":"Runtime Selector","text":"<p>The top app selector controls runtime-specific content visibility.</p>"},{"location":"runtime-guides/runtime-selector/#behavior","title":"Behavior","text":"<ul> <li>selection persists in <code>localStorage</code></li> <li>non-selected runtime blocks are hidden</li> <li>shared content remains visible</li> </ul>"},{"location":"runtime-guides/runtime-selector/#authoring-classes","title":"Authoring classes","text":"<ul> <li><code>.runtime-dotnet</code></li> <li><code>.runtime-typescript</code></li> </ul>"},{"location":"runtime-guides/streaming/","title":"Streaming","text":"<p>Streaming is used for large inputs where whole-document materialization is unnecessary.</p>   ## .NET  - `StreamJsonArrayConversionAsync` - `StreamConversionAsync` with `JsonArray`, `Ndjson`, `QueryLines`, `XmlElements`     ## TypeScript  - `streamJsonArrayConversion` - `streamConversion` with `jsonArray`, `ndjson`, `queryLines`, `xmlElements`"},{"location":"runtime-guides/typescript-api-usage/","title":"TypeScript API Usage","text":"Use package exports for normalize/parse/apply/format workflows.  <pre><code>import { normalizeConversionRulesStrict, compileConversionPlan } from \"@apiconvert/core\";\n\nconst rules = normalizeConversionRulesStrict(rulesText);\nconst plan = compileConversionPlan(rules);\nconst result = plan.apply(input);\n</code></pre>  Key APIs:  - `normalizeConversionRulesStrict` - `applyConversion` - `compileConversionPlan` - `lintConversionRules` - `checkRulesCompatibility`"},{"location":"schema-versioning/breaking-changes/","title":"Breaking Change Policy","text":"<p>For breaking schema/runtime behavior changes:</p> <ul> <li>bump major version</li> <li>document migration guidance</li> <li>add parity tests covering old/new behavior boundaries</li> <li>update versioned schema artifacts</li> </ul>"},{"location":"schema-versioning/contract/","title":"Schema Compatibility Contract","text":"<p>Rules schema is a cross-runtime compatibility contract.</p> <p>Any change to rule shape, validation behavior, or source/node semantics must preserve backward compatibility or be explicitly versioned.</p>"},{"location":"schema-versioning/semver-lockstep/","title":"SemVer Lockstep","text":"<p>Repository, package versions, and schema versions are lockstep:</p> <ul> <li>Git tag: <code>vX.Y.Z</code></li> <li>NuGet: <code>X.Y.Z</code></li> <li>npm: <code>X.Y.Z</code></li> <li>schema: <code>X.Y.Z</code></li> </ul>"},{"location":"schema-versioning/version-pinning/","title":"Version Pinning","text":"<p>Use immutable versioned schema paths for strict pinning:</p> <ul> <li><code>schemas/rules/vX.Y.Z/schema.json</code></li> </ul> <p>Use <code>schemas/rules/current/schema.json</code> when tracking latest release.</p>"},{"location":"start-here/first-conversion/","title":"First Conversion","text":"<p>This walkthrough maps <code>user.fullName</code> to <code>customer.name</code> using one <code>field</code> rule.</p>"},{"location":"start-here/first-conversion/#rules","title":"Rules","text":"<pre><code>{\n  \"inputFormat\": \"json\",\n  \"outputFormat\": \"json\",\n  \"rules\": [\n    {\n      \"kind\": \"field\",\n      \"outputPaths\": [\"customer.name\"],\n      \"source\": { \"type\": \"path\", \"path\": \"user.fullName\" }\n    }\n  ]\n}\n</code></pre>   ## .NET  <pre><code>using Apiconvert.Core.Converters;\n\nvar rules = ConversionEngine.NormalizeConversionRulesStrict(rulesJson);\nvar (value, error) = ConversionEngine.ParsePayload(\"{\\\"user\\\":{\\\"fullName\\\":\\\"Ada\\\"}}\", rules.InputFormat);\nif (error is not null) throw new Exception(error);\n\nvar result = ConversionEngine.ApplyConversion(value, rules);\nif (result.Errors.Count &gt; 0) throw new Exception(string.Join(\"; \", result.Errors));\n\nvar output = ConversionEngine.FormatPayload(result.Output, rules.OutputFormat, pretty: true);\n</code></pre>   ## TypeScript  <pre><code>import { normalizeConversionRulesStrict, parsePayload, applyConversion, formatPayload } from \"@apiconvert/core\";\n\nconst rules = normalizeConversionRulesStrict(rulesJson);\nconst { value, error } = parsePayload('{\"user\":{\"fullName\":\"Ada\"}}', rules.inputFormat!);\nif (error) throw new Error(error);\n\nconst result = applyConversion(value, rules);\nif (result.errors.length &gt; 0) throw new Error(result.errors.join(\"; \"));\n\nconst output = formatPayload(result.output, rules.outputFormat!, true);\n</code></pre>"},{"location":"start-here/install/","title":"Install","text":""},{"location":"start-here/install/#net","title":".NET","text":"<pre><code>dotnet add package Apiconvert.Core\n</code></pre>"},{"location":"start-here/install/#typescript","title":"TypeScript","text":"<pre><code>npm install @apiconvert/core\n</code></pre>"},{"location":"start-here/install/#verify-setup","title":"Verify setup","text":"<pre><code>dotnet --version\nnode --version\nnpm --version\n</code></pre>"},{"location":"start-here/migration/","title":"Migration from Hand-Written Mappers","text":""},{"location":"start-here/migration/#recommended-migration-steps","title":"Recommended migration steps","text":"<ol> <li>Start with one high-value conversion and model it as rules.</li> <li>Validate with strict normalization before runtime use.</li> <li>Add shared <code>tests/cases</code> coverage for the conversion.</li> <li>Compile plans if you run the same rules repeatedly.</li> <li>Adopt lint + doctor checks in CI before cutting over.</li> </ol>"},{"location":"start-here/migration/#why-migrate","title":"Why migrate","text":"<ul> <li>deterministic behavior with explicit schema contract</li> <li>shared behavior across .NET and TypeScript</li> <li>diagnostics with stable codes</li> <li>easier parity testing with shared case files</li> </ul>"}]}